  import React, { useState, useRef, useEffect , useCallback} from 'react';
  import rangy from 'rangy';
  import "rangy/lib/rangy-classapplier";
import "rangy/lib/rangy-highlighter";
  import ReactMarkdown from 'react-markdown';
  import contentStyle from '../styles/content.module.css'
  import highStyles from "../styles/highlight.module.css"
  import '@blueprintjs/core/lib/css/blueprint.css';
  import { Popover, Button, Classes } from '@blueprintjs/core';
  import { Highlight } from '@blueprintjs/icons';
  import { handle_highlight_preserve } from './HandleHighlightPreserve';
  function init(){
    console.log("ramgy called")
    try{
    rangy.init()
    console.log(rangy)
    }catch(e){console.log(e)}
  }
  function wrapTextWithHighlight(selection) {
    if (!selection || selection.isCollapsed) {
      return; // No text selected or empty selection
    }
  
    const range = selection.getRangeAt(0);
    console.log(range)
    
    const startContainer = range.startContainer;
    const endContainer = range.endContainer;
  
    // Create a new span element for highlighting
    const highlightSpan = document.createElement('span');
    highlightSpan.classList.add(contentStyle.highlighted);
  
    // Wrap the selected text with the highlight span
    range.surroundContents(highlightSpan);
  
    // Check for incomplete child elements at the start and end of the selection
    if (startContainer.nodeType === 1 && !startContainer.contains(range.startOffset)) {
      const cloneStart = startContainer.cloneNode(true);
      startContainer.textContent = '';
      startContainer.appendChild(cloneStart);
    }
  
    if (endContainer.nodeType === 1 && !endContainer.contains(range.endOffset)) {
      const cloneEnd = endContainer.cloneNode(true);
      endContainer.textContent = '';
      endContainer.appendChild(cloneEnd);
    }
  }
  
  function removeHighlightFromSelection(selection) {
    if (!selection || selection.isCollapsed) {
      return; // No text selected or empty selection
    }
  
    const range = selection.getRangeAt(0);
  
    // Use document.querySelectorAll() to find all elements with the class
    // name generated by your CSS module
    const highlightSpans = document.querySelectorAll(`.${contentStyle.highlighted}`);
  
    highlightSpans.forEach((span) => {
      if (range.intersectsNode(span)) {
        const spanText = span.textContent;
        const textNode = document.createTextNode(spanText);
        span.parentNode.insertBefore(textNode, span);
        span.parentNode.removeChild(span);
      }
    });
  }
  
  
  const MarkdownWithOverlay = ({ markdownContent,user,postId, highlights }) => {
    
    const [highlightedText,setHighlightedText] = useState('')
    const [selectedTexttwo, setSelectedTexttwo] = useState('');
    const [popupPositiontwo, setPopupPositiontwo] = useState({});
    const [selectionInfo, setSelectionInfo] = useState(null);
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const containerRef = useRef(null);
    const popoverRef = useRef(null);
    const highlighterRef = useRef(null);
  
    const serializedHighlightedDataRef = useRef(highlights?.highlightedText ?? "")
    useEffect(()=>{
        init();
        const highlighter = rangy.createHighlighter();
        highlighter.addClassApplier(
          rangy.createClassApplier(highStyles.highlight, {
            ignoreWhiteSpace: true,
            elementTagName: "mark",
            tagNames: ["mark"]
          })
        );
        highlighterRef.current = highlighter;
        console.log("hehehhehhehhehhehhehhehheh",highlights)
        if(serializedHighlightedDataRef.current){
        highlighter.deserialize(serializedHighlightedDataRef.current )}
    },[])




    const handleSaveHighlight = useCallback(async () => {
      const highlighter =  highlighterRef.current
      
      // highlighter.addClassApplier(
      //   rangy.createClassApplier(highStyles.highlight, {
      //     ignoreWhiteSpace: true,
      //     elementTagName: "mark",
      //     tagNames: ["mark"]
      //   })
      // );
  
      highlighter.highlightSelection(highStyles.highlight);
  
      console.log("highlighter.highlights", highlighter.highlights);
      console.log(
        "highlighter.highlights[0].getHighlightElements()",
        highlighter.highlights[0].getHighlightElements()
      );
      console.log(
        "highlighter.highlights :: getText",
        highlighter.highlights.map((h) => h.getText())
      );
      const serialized = highlighter.serialize();
      console.log("serrrr", serialized);
      console.log("post id ", postId)
      serializedHighlightedDataRef.current = serialized
      try{
        console.log(postId)
        const uri = process.env.backendUrl+`api/post/update/highlight/${postId}`

        const response = await fetch(uri,{
          credentials:'include',
          method:'PATCH',
          headers:{
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ highlightedText:serializedHighlightedDataRef.current })
          

        })
        if(response.ok){
          console.log("backend succes")
        }


      

      }catch(e){}
      console.log("test", serializedHighlightedDataRef.current);
    }, []);
    const handleTextSelection = () => {
      const text = window.getSelection().toString().trim();
      if (text) {
        setSelectedTexttwo(text);
        

        // Get the position of the selected text (e.g., use the mouse event)
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();

          setPopupPositiontwo({
            top: rect.top + window.scrollY - 20, // Adjust the top position as needed
            left: rect.left + window.scrollX + rect.width / 2 - 100, // Adjust the left position as needed
          });

          // Open the popover
          setIsPopoverOpen(true);
        }
      } else {
        setSelectedTexttwo('');
        // Close the popover when selection is cleared
        setIsPopoverOpen(false);
      }
    };
    // const highlightedStyle = {
    //   backgroundColor: Highlighted ? 'yellow' : 'transparent', // Change the background color as needed
    // };
    const applyHighLight  = (range)=>{
      const span = document.createElement('span');
      span.classList.add(contentStyle.highlighted)
      range.surroundContents(span);
    }
    
    const highlightData = {
      endContainerHTML:"<h2>Whats our Position Now</h2>",
      endOffset:22,
      selectedText:"Now",
      startContainerHTML:"<h2>Whats our Position Now</h2>",
      startOffset:19,
    };
    function reconstructHighlight(highlightData) {
      const { selectedText, startContainerHTML, endContainerHTML, startOffset, endOffset } = highlightData;
    
      // Create a range and wrap it with the highlighting
      const range = document.createRange();
    
      // Create temporary divs to hold the HTML content
      const startContainer = document.createElement('div');
      startContainer.innerHTML = startContainerHTML;
      const endContainer = document.createElement('div');
      endContainer.innerHTML = endContainerHTML;
      console.log("fitrst conmtaiber : ")
    
      // Set the range's start and end
      
    }
    
    // Call the function to reconstruct the highlighting
    
    
    const handleHighlight = ()=>{
      console.log("highlighting")
      console.log(selectedTexttwo)
      if(selectedTexttwo){
        handle_highlight_preserve(window.getSelection(),selectedTexttwo)
        wrapTextWithHighlight(window.getSelection());
      }
    }

    const handleRemoveHighlight = ()=>{
      if (selectedTexttwo){
        removeHighlightFromSelection(window.getSelection());
      }
    }
    const handleMouseDown = () => {
      setSelectedTexttwo('');
      // Close the popover when the mouse is clicked outside
      setIsPopoverOpen(false);
    };
    const updatePopoverPosition = () => {
      if (selectionInfo) {
        const range = window.getSelection().getRangeAt(0);
        const rects = range.getClientRects();

        if (rects.length > 0) {
          const lastRect = rects[rects.length - 1];
          const containerRect = containerRef.current.getBoundingClientRect();

          const newPosition = {
            top: lastRect.bottom - containerRect.top + window.scrollY,
            left: lastRect.left - containerRect.left + window.scrollX + (lastRect.width / 2),
          };

          setSelectionInfo(prevInfo => ({
            ...prevInfo,
            position: newPosition,
          }));
        }
      }
    };

    const handleSelection = () => {
      const selection = window.getSelection();
      const selectedText = selection.toString();

      if (selectedText) {
        const range = selection.getRangeAt(0);
        const rects = range.getClientRects();
        console.log("rects , ",rects)
        if (rects.length > 0) {
          const lastRect = rects[rects.length - 1];
          const containerRect = containerRef.current.getBoundingClientRect();

          const initialPosition = {
            top: lastRect.bottom - containerRect.top + window.scrollY,
            left: lastRect.left - containerRect.left + window.scrollX + (lastRect.width / 2),
          };

          setSelectionInfo({
            text: selectedText,
            position: initialPosition,
          });


          setIsPopoverOpen(true);
          updatePopoverPosition();
        }
      } else {
        setSelectionInfo(null);
        setIsPopoverOpen(false);
      }
    };
  
    useEffect(() => {
      if (isPopoverOpen) {
        const popoverElement = popoverRef.current;
        if (popoverElement) {
          popoverElement.focus();
        }
      }
    }, [isPopoverOpen]);
    useEffect(() => {
      updatePopoverPosition(); // Update position after component mounts
    }, []);

    const imageStyle = {
      width: '25%',
      height: '25%',
    };
    const CustomImage = ({ node, src, alt, ...props }) => {
      const imageStyle = {
        width: '100%',
        height: '100%',
        padding:'2%',
        
      };
      const divStyle = {
        display:'flex',
        justifyContent:'center',
        alignItems:'center'
      }
    
      return (
        <div style={divStyle}>
      
        <img
          className={contentStyle.customImage} // Define your custom image style class here
          src={src}
          alt={alt}
          style={imageStyle}
          {...props}
        />
        </div>
      );
    };

    

    return (
      <div style={{ position: 'static' }}>
        <div onMouseUp={handleTextSelection}
          onMouseDown={handleMouseDown}
          className={contentStyle.contentClass}
          style={{ position: 'relative' }} >
          <div style={{display:'flex',justifyContent:'space-between'}}>
          
          </div>
          <ReactMarkdown
          suppressHydrationWarning
              components={{
                  blockquote: ({ node, ...props }) => (
                      <blockquote className={contentStyle.customblockquote} {...props} />
                    ),
                  code: ({ node, inline, className, children, ...props }) => {
                    if (inline) {
                      return <code className={className} {...props}>{children}</code>;
                    } else {
                      return (
                        <div className={contentStyle.codeblock}>
                          <code className={className} {...props}>{children}</code>
                        </div>
                      );
                    }
                  },
                  
                  img:CustomImage,
                  
                  
                }}
          >{markdownContent}</ReactMarkdown>
          
        </div>
        {selectedTexttwo && (
          <Popover
              
          isOpen={isPopoverOpen}
          position="auto"
          onClose={() => setIsPopoverOpen(false)}
        >
          <div
            style={{
              
              position: 'absolute',
              top: popupPositiontwo.top,
              left: popupPositiontwo.left,
              backgroundColor: 'rgba(18, 18, 18,0.789797)',
            
              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
              padding: '10px',
              borderRadius:'5px'
            }}
          >
            
              <div style={{ padding: '10%', display: 'flex', flexDirection: 'row', justifyContent: 'space-around' }}>
                  <Button

                    icon={<Highlight size={16} color='white' />}
                    style={{ padding: '2%', margin: '2%', width: 'fit-content', border:'none' , background:'inherit'}}
                    onClick={() => {handleSaveHighlight();setIsPopoverOpen(false)}}
                  />
                  <Button
                    style={{ padding: '2%', margin: '2%',border:'none' , background:'inherit' }}
                    icon={<Highlight size={16} color='white' />}
                    onClick={() =>{ handleRemoveHighlight(); setIsPopoverOpen(false)}}
                  />
                  {/* reconstructHighlight(highlightData); */}
                  <Button
                    style={{ padding: '2%', margin: '2%',border:'none' , background:'inherit' }}
                    icon={<Highlight size={16} color='white' />}
                    onClick={() =>{reconstructHighlight(highlightData); }}
                  />
                </div>
                </div>
            </Popover>
          
        )}
      </div>
    );
  };

  export default MarkdownWithOverlay;
